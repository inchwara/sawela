"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/breakages/layout",{

/***/ "(app-pages-browser)/./lib/auth-refresh.ts":
/*!*****************************!*\
  !*** ./lib/auth-refresh.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupAuthMonitoring: () => (/* binding */ cleanupAuthMonitoring),\n/* harmony export */   getAuthStatus: () => (/* binding */ getAuthStatus),\n/* harmony export */   initializeAuthMonitoring: () => (/* binding */ initializeAuthMonitoring),\n/* harmony export */   refreshAuthToken: () => (/* binding */ refreshAuthToken),\n/* harmony export */   startPermissionSync: () => (/* binding */ startPermissionSync),\n/* harmony export */   startTokenRefreshMonitor: () => (/* binding */ startTokenRefreshMonitor),\n/* harmony export */   stopPermissionSync: () => (/* binding */ stopPermissionSync),\n/* harmony export */   stopTokenRefreshMonitor: () => (/* binding */ stopTokenRefreshMonitor),\n/* harmony export */   syncPermissions: () => (/* binding */ syncPermissions)\n/* harmony export */ });\n/* harmony import */ var _token_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token-manager */ \"(app-pages-browser)/./lib/token-manager.ts\");\n/* harmony import */ var _permission_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./permission-manager */ \"(app-pages-browser)/./lib/permission-manager.ts\");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api */ \"(app-pages-browser)/./lib/api.ts\");\n/**\n * Auth Refresh Service\n * Handles automatic token refresh and permission sync\n */ \n\n\nlet refreshPromise = null;\nlet refreshTimer = null;\nlet permissionSyncTimer = null;\n/**\n * Refresh the authentication token\n * Returns a promise that resolves to the new token\n */ async function refreshAuthToken() {\n    // If a refresh is already in progress, return that promise\n    if (refreshPromise) {\n        return refreshPromise;\n    }\n    refreshPromise = (async ()=>{\n        try {\n            var _data_data;\n            const currentToken = (0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.getToken)();\n            if (!currentToken) {\n                throw new Error('No token to refresh');\n            }\n            // Call the refresh endpoint (adjust endpoint as needed)\n            // Note: If your API doesn't have a refresh endpoint, this will fetch user profile instead\n            const response = await fetch(\"\".concat(\"http://localhost:8000/api\" || 0, \"/user\"), {\n                method: 'GET',\n                headers: {\n                    'Authorization': \"Bearer \".concat(currentToken),\n                    'Accept': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error('Token refresh failed');\n            }\n            const data = await response.json();\n            // If the API returns a new token, store it\n            // Otherwise, the token is still valid (Sanctum tokens don't expire by default)\n            if ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.token) {\n                (0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.storeToken)(data.data.token);\n                return data.data.token;\n            }\n            // If no new token, the current one is still valid\n            return currentToken;\n        } catch (error) {\n            console.error('Token refresh failed:', error);\n            throw error;\n        } finally{\n            refreshPromise = null;\n        }\n    })();\n    return refreshPromise;\n}\n/**\n * Sync permissions from the server\n * Note: This is a background sync feature - errors are silenced to not disrupt the user experience\n */ async function syncPermissions() {\n    try {\n        var _response_data;\n        const userData = (0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.getUserData)();\n        if (!userData || !userData.id) return;\n        // Fetch fresh user data including permissions using the users endpoint\n        const response = await (0,_api__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"/users/\".concat(userData.id), 'GET', undefined, true);\n        if (response.status === 'success' && ((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.user)) {\n            // Update user data with fresh permissions\n            (0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.storeUserData)(response.data.user);\n        }\n    } catch (error) {\n        // Silently fail - this is a background sync feature\n        // The user can continue using the app with cached permissions\n        if (true) {\n            console.debug('Permission sync skipped:', error);\n        }\n    }\n}\n/**\n * Start automatic token refresh\n * Monitors token expiration and refreshes proactively\n */ function startTokenRefreshMonitor() {\n    // Clear any existing timer\n    if (refreshTimer) {\n        clearInterval(refreshTimer);\n    }\n    const checkAndRefresh = async ()=>{\n        try {\n            // If token is expired, trigger logout (handled by auth context)\n            if ((0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.isTokenExpired)()) {\n                stopTokenRefreshMonitor();\n                return;\n            }\n            // If token should be refreshed (within threshold), refresh it\n            if ((0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.shouldRefreshToken)()) {\n                await refreshAuthToken();\n            }\n        } catch (error) {\n            console.error('Token refresh check failed:', error);\n        }\n    };\n    // Check every 2 minutes\n    refreshTimer = setInterval(checkAndRefresh, 2 * 60 * 1000);\n    // Also check immediately\n    checkAndRefresh();\n}\n/**\n * Stop automatic token refresh\n */ function stopTokenRefreshMonitor() {\n    if (refreshTimer) {\n        clearInterval(refreshTimer);\n        refreshTimer = null;\n    }\n}\n/**\n * Start automatic permission sync\n * Keeps permissions fresh without disrupting user experience\n */ function startPermissionSync() {\n    // Clear any existing timer\n    if (permissionSyncTimer) {\n        clearInterval(permissionSyncTimer);\n    }\n    const checkAndSync = async ()=>{\n        try {\n            const userData = (0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.getUserData)();\n            if (!userData) return;\n            // If permission cache is invalid, sync permissions\n            if (!(0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.isPermissionCacheValid)(userData.id)) {\n                await syncPermissions();\n            }\n        } catch (error) {\n            console.error('Permission sync check failed:', error);\n        }\n    };\n    // Sync every 10 minutes\n    permissionSyncTimer = setInterval(checkAndSync, 10 * 60 * 1000);\n    // Also check immediately if cache is invalid\n    checkAndSync();\n}\n/**\n * Stop automatic permission sync\n */ function stopPermissionSync() {\n    if (permissionSyncTimer) {\n        clearInterval(permissionSyncTimer);\n        permissionSyncTimer = null;\n    }\n}\n/**\n * Initialize auth monitoring (token refresh + permission sync)\n * Call this when user logs in\n */ function initializeAuthMonitoring() {\n    startTokenRefreshMonitor();\n    startPermissionSync();\n}\n/**\n * Cleanup auth monitoring\n * Call this when user logs out\n */ function cleanupAuthMonitoring() {\n    stopTokenRefreshMonitor();\n    stopPermissionSync();\n    (0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.clearPermissionCache)();\n}\n/**\n * Get authentication status for debugging\n */ function getAuthStatus() {\n    return {\n        tokenExpired: (0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.isTokenExpired)(),\n        shouldRefresh: (0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.shouldRefreshToken)(),\n        timeUntilExpiry: (0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.getTimeUntilExpiry)(),\n        hasToken: !!(0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.getToken)(),\n        hasUserData: !!(0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.getUserData)(),\n        monitoringActive: !!refreshTimer,\n        syncActive: !!permissionSyncTimer\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hdXRoLXJlZnJlc2gudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBRThHO0FBQ0M7QUFDcEY7QUFXNUIsSUFBSVUsaUJBQXlDO0FBQzdDLElBQUlDLGVBQXNDO0FBQzFDLElBQUlDLHNCQUE2QztBQUVqRDs7O0NBR0MsR0FDTSxlQUFlQztJQUNwQiwyREFBMkQ7SUFDM0QsSUFBSUgsZ0JBQWdCO1FBQ2xCLE9BQU9BO0lBQ1Q7SUFFQUEsaUJBQWlCLENBQUM7UUFDaEIsSUFBSTtnQkF3QkVJO1lBdkJKLE1BQU1DLGVBQWVmLHdEQUFRQTtZQUM3QixJQUFJLENBQUNlLGNBQWM7Z0JBQ2pCLE1BQU0sSUFBSUMsTUFBTTtZQUNsQjtZQUVBLHdEQUF3RDtZQUN4RCwwRkFBMEY7WUFDMUYsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQWtFLE9BQS9EQywyQkFBK0IsSUFBSSxDQUEyQixFQUFDLFVBQVE7Z0JBQ3JHRyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGlCQUFpQixVQUF1QixPQUFiUjtvQkFDM0IsVUFBVTtnQkFDWjtZQUNGO1lBRUEsSUFBSSxDQUFDRSxTQUFTTyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSVIsTUFBTTtZQUNsQjtZQUVBLE1BQU1GLE9BQU8sTUFBTUcsU0FBU1EsSUFBSTtZQUVoQywyQ0FBMkM7WUFDM0MsK0VBQStFO1lBQy9FLEtBQUlYLGFBQUFBLEtBQUtBLElBQUksY0FBVEEsaUNBQUFBLFdBQVdZLEtBQUssRUFBRTtnQkFDcEJ6QiwwREFBVUEsQ0FBQ2EsS0FBS0EsSUFBSSxDQUFDWSxLQUFLO2dCQUMxQixPQUFPWixLQUFLQSxJQUFJLENBQUNZLEtBQUs7WUFDeEI7WUFFQSxrREFBa0Q7WUFDbEQsT0FBT1g7UUFDVCxFQUFFLE9BQU9ZLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsTUFBTUE7UUFDUixTQUFVO1lBQ1JqQixpQkFBaUI7UUFDbkI7SUFDRjtJQUVBLE9BQU9BO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDTSxlQUFlbUI7SUFDcEIsSUFBSTtZQU9tQ1o7UUFOckMsTUFBTWEsV0FBV3pCLGdFQUFXQTtRQUM1QixJQUFJLENBQUN5QixZQUFZLENBQUNBLFNBQVNDLEVBQUUsRUFBRTtRQUUvQix1RUFBdUU7UUFDdkUsTUFBTWQsV0FBVyxNQUFNUixnREFBT0EsQ0FBa0IsVUFBc0IsT0FBWnFCLFNBQVNDLEVBQUUsR0FBSSxPQUFPQyxXQUFXO1FBRTNGLElBQUlmLFNBQVNnQixNQUFNLEtBQUssZUFBYWhCLGlCQUFBQSxTQUFTSCxJQUFJLGNBQWJHLHFDQUFBQSxlQUFlaUIsSUFBSSxHQUFFO1lBQ3hELDBDQUEwQztZQUMxQzVCLGtFQUFhQSxDQUFDVyxTQUFTSCxJQUFJLENBQUNvQixJQUFJO1FBQ2xDO0lBQ0YsRUFBRSxPQUFPUCxPQUFPO1FBQ2Qsb0RBQW9EO1FBQ3BELDhEQUE4RDtRQUM5RCxJQUFJUixJQUFzQyxFQUFFO1lBQzFDUyxRQUFRTyxLQUFLLENBQUMsNEJBQTRCUjtRQUM1QztJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxTQUFTUztJQUNkLDJCQUEyQjtJQUMzQixJQUFJekIsY0FBYztRQUNoQjBCLGNBQWMxQjtJQUNoQjtJQUVBLE1BQU0yQixrQkFBa0I7UUFDdEIsSUFBSTtZQUNGLGdFQUFnRTtZQUNoRSxJQUFJbkMsOERBQWNBLElBQUk7Z0JBQ3BCb0M7Z0JBQ0E7WUFDRjtZQUVBLDhEQUE4RDtZQUM5RCxJQUFJckMsa0VBQWtCQSxJQUFJO2dCQUN4QixNQUFNVztZQUNSO1FBQ0YsRUFBRSxPQUFPYyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywrQkFBK0JBO1FBQy9DO0lBQ0Y7SUFFQSx3QkFBd0I7SUFDeEJoQixlQUFlNkIsWUFBWUYsaUJBQWlCLElBQUksS0FBSztJQUVyRCx5QkFBeUI7SUFDekJBO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDO0lBQ2QsSUFBSTVCLGNBQWM7UUFDaEIwQixjQUFjMUI7UUFDZEEsZUFBZTtJQUNqQjtBQUNGO0FBRUE7OztDQUdDLEdBQ00sU0FBUzhCO0lBQ2QsMkJBQTJCO0lBQzNCLElBQUk3QixxQkFBcUI7UUFDdkJ5QixjQUFjekI7SUFDaEI7SUFFQSxNQUFNOEIsZUFBZTtRQUNuQixJQUFJO1lBQ0YsTUFBTVosV0FBV3pCLGdFQUFXQTtZQUM1QixJQUFJLENBQUN5QixVQUFVO1lBRWYsbURBQW1EO1lBQ25ELElBQUksQ0FBQ3ZCLDJFQUFzQkEsQ0FBQ3VCLFNBQVNDLEVBQUUsR0FBRztnQkFDeEMsTUFBTUY7WUFDUjtRQUNGLEVBQUUsT0FBT0YsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsaUNBQWlDQTtRQUNqRDtJQUNGO0lBRUEsd0JBQXdCO0lBQ3hCZixzQkFBc0I0QixZQUFZRSxjQUFjLEtBQUssS0FBSztJQUUxRCw2Q0FBNkM7SUFDN0NBO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDO0lBQ2QsSUFBSS9CLHFCQUFxQjtRQUN2QnlCLGNBQWN6QjtRQUNkQSxzQkFBc0I7SUFDeEI7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNnQztJQUNkUjtJQUNBSztBQUNGO0FBRUE7OztDQUdDLEdBQ00sU0FBU0k7SUFDZE47SUFDQUk7SUFDQW5DLHlFQUFvQkE7QUFDdEI7QUFFQTs7Q0FFQyxHQUNNLFNBQVNzQztJQUNkLE9BQU87UUFDTEMsY0FBYzVDLDhEQUFjQTtRQUM1QjZDLGVBQWU5QyxrRUFBa0JBO1FBQ2pDK0MsaUJBQWlCN0Msa0VBQWtCQTtRQUNuQzhDLFVBQVUsQ0FBQyxDQUFDbEQsd0RBQVFBO1FBQ3BCbUQsYUFBYSxDQUFDLENBQUM5QyxnRUFBV0E7UUFDMUIrQyxrQkFBa0IsQ0FBQyxDQUFDekM7UUFDcEIwQyxZQUFZLENBQUMsQ0FBQ3pDO0lBQ2hCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pbmNod2FyYS9zYXdlbGEvbGliL2F1dGgtcmVmcmVzaC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF1dGggUmVmcmVzaCBTZXJ2aWNlXG4gKiBIYW5kbGVzIGF1dG9tYXRpYyB0b2tlbiByZWZyZXNoIGFuZCBwZXJtaXNzaW9uIHN5bmNcbiAqL1xuXG5pbXBvcnQgeyBnZXRUb2tlbiwgc3RvcmVUb2tlbiwgc2hvdWxkUmVmcmVzaFRva2VuLCBpc1Rva2VuRXhwaXJlZCwgZ2V0VGltZVVudGlsRXhwaXJ5IH0gZnJvbSAnLi90b2tlbi1tYW5hZ2VyJztcbmltcG9ydCB7IGdldFVzZXJEYXRhLCBzdG9yZVVzZXJEYXRhLCBpc1Blcm1pc3Npb25DYWNoZVZhbGlkLCBjbGVhclBlcm1pc3Npb25DYWNoZSB9IGZyb20gJy4vcGVybWlzc2lvbi1tYW5hZ2VyJztcbmltcG9ydCBhcGlDYWxsIGZyb20gJy4vYXBpJztcblxuaW50ZXJmYWNlIFJlZnJlc2hSZXNwb25zZSB7XG4gIHN0YXR1czogc3RyaW5nO1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIGRhdGE6IHtcbiAgICB0b2tlbjogc3RyaW5nO1xuICAgIHVzZXI6IGFueTtcbiAgfTtcbn1cblxubGV0IHJlZnJlc2hQcm9taXNlOiBQcm9taXNlPHN0cmluZz4gfCBudWxsID0gbnVsbDtcbmxldCByZWZyZXNoVGltZXI6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG5sZXQgcGVybWlzc2lvblN5bmNUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblxuLyoqXG4gKiBSZWZyZXNoIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlblxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbmV3IHRva2VuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWZyZXNoQXV0aFRva2VuKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gIC8vIElmIGEgcmVmcmVzaCBpcyBhbHJlYWR5IGluIHByb2dyZXNzLCByZXR1cm4gdGhhdCBwcm9taXNlXG4gIGlmIChyZWZyZXNoUHJvbWlzZSkge1xuICAgIHJldHVybiByZWZyZXNoUHJvbWlzZTtcbiAgfVxuXG4gIHJlZnJlc2hQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFRva2VuID0gZ2V0VG9rZW4oKTtcbiAgICAgIGlmICghY3VycmVudFRva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdG9rZW4gdG8gcmVmcmVzaCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxsIHRoZSByZWZyZXNoIGVuZHBvaW50IChhZGp1c3QgZW5kcG9pbnQgYXMgbmVlZGVkKVxuICAgICAgLy8gTm90ZTogSWYgeW91ciBBUEkgZG9lc24ndCBoYXZlIGEgcmVmcmVzaCBlbmRwb2ludCwgdGhpcyB3aWxsIGZldGNoIHVzZXIgcHJvZmlsZSBpbnN0ZWFkXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3Byb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGknfS91c2VyYCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7Y3VycmVudFRva2VufWAsXG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiByZWZyZXNoIGZhaWxlZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAvLyBJZiB0aGUgQVBJIHJldHVybnMgYSBuZXcgdG9rZW4sIHN0b3JlIGl0XG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSB0b2tlbiBpcyBzdGlsbCB2YWxpZCAoU2FuY3R1bSB0b2tlbnMgZG9uJ3QgZXhwaXJlIGJ5IGRlZmF1bHQpXG4gICAgICBpZiAoZGF0YS5kYXRhPy50b2tlbikge1xuICAgICAgICBzdG9yZVRva2VuKGRhdGEuZGF0YS50b2tlbik7XG4gICAgICAgIHJldHVybiBkYXRhLmRhdGEudG9rZW47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIG5ldyB0b2tlbiwgdGhlIGN1cnJlbnQgb25lIGlzIHN0aWxsIHZhbGlkXG4gICAgICByZXR1cm4gY3VycmVudFRva2VuO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUb2tlbiByZWZyZXNoIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVmcmVzaFByb21pc2UgPSBudWxsO1xuICAgIH1cbiAgfSkoKTtcblxuICByZXR1cm4gcmVmcmVzaFByb21pc2U7XG59XG5cbi8qKlxuICogU3luYyBwZXJtaXNzaW9ucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIE5vdGU6IFRoaXMgaXMgYSBiYWNrZ3JvdW5kIHN5bmMgZmVhdHVyZSAtIGVycm9ycyBhcmUgc2lsZW5jZWQgdG8gbm90IGRpc3J1cHQgdGhlIHVzZXIgZXhwZXJpZW5jZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3luY1Blcm1pc3Npb25zKCk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXJEYXRhID0gZ2V0VXNlckRhdGEoKTtcbiAgICBpZiAoIXVzZXJEYXRhIHx8ICF1c2VyRGF0YS5pZCkgcmV0dXJuO1xuXG4gICAgLy8gRmV0Y2ggZnJlc2ggdXNlciBkYXRhIGluY2x1ZGluZyBwZXJtaXNzaW9ucyB1c2luZyB0aGUgdXNlcnMgZW5kcG9pbnRcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNhbGw8UmVmcmVzaFJlc3BvbnNlPihgL3VzZXJzLyR7dXNlckRhdGEuaWR9YCwgJ0dFVCcsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAnc3VjY2VzcycgJiYgcmVzcG9uc2UuZGF0YT8udXNlcikge1xuICAgICAgLy8gVXBkYXRlIHVzZXIgZGF0YSB3aXRoIGZyZXNoIHBlcm1pc3Npb25zXG4gICAgICBzdG9yZVVzZXJEYXRhKHJlc3BvbnNlLmRhdGEudXNlcik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFNpbGVudGx5IGZhaWwgLSB0aGlzIGlzIGEgYmFja2dyb3VuZCBzeW5jIGZlYXR1cmVcbiAgICAvLyBUaGUgdXNlciBjYW4gY29udGludWUgdXNpbmcgdGhlIGFwcCB3aXRoIGNhY2hlZCBwZXJtaXNzaW9uc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc29sZS5kZWJ1ZygnUGVybWlzc2lvbiBzeW5jIHNraXBwZWQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFN0YXJ0IGF1dG9tYXRpYyB0b2tlbiByZWZyZXNoXG4gKiBNb25pdG9ycyB0b2tlbiBleHBpcmF0aW9uIGFuZCByZWZyZXNoZXMgcHJvYWN0aXZlbHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0VG9rZW5SZWZyZXNoTW9uaXRvcigpOiB2b2lkIHtcbiAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyXG4gIGlmIChyZWZyZXNoVGltZXIpIHtcbiAgICBjbGVhckludGVydmFsKHJlZnJlc2hUaW1lcik7XG4gIH1cblxuICBjb25zdCBjaGVja0FuZFJlZnJlc2ggPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIHRva2VuIGlzIGV4cGlyZWQsIHRyaWdnZXIgbG9nb3V0IChoYW5kbGVkIGJ5IGF1dGggY29udGV4dClcbiAgICAgIGlmIChpc1Rva2VuRXhwaXJlZCgpKSB7XG4gICAgICAgIHN0b3BUb2tlblJlZnJlc2hNb25pdG9yKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdG9rZW4gc2hvdWxkIGJlIHJlZnJlc2hlZCAod2l0aGluIHRocmVzaG9sZCksIHJlZnJlc2ggaXRcbiAgICAgIGlmIChzaG91bGRSZWZyZXNoVG9rZW4oKSkge1xuICAgICAgICBhd2FpdCByZWZyZXNoQXV0aFRva2VuKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggY2hlY2sgZmFpbGVkOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2hlY2sgZXZlcnkgMiBtaW51dGVzXG4gIHJlZnJlc2hUaW1lciA9IHNldEludGVydmFsKGNoZWNrQW5kUmVmcmVzaCwgMiAqIDYwICogMTAwMCk7XG5cbiAgLy8gQWxzbyBjaGVjayBpbW1lZGlhdGVseVxuICBjaGVja0FuZFJlZnJlc2goKTtcbn1cblxuLyoqXG4gKiBTdG9wIGF1dG9tYXRpYyB0b2tlbiByZWZyZXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wVG9rZW5SZWZyZXNoTW9uaXRvcigpOiB2b2lkIHtcbiAgaWYgKHJlZnJlc2hUaW1lcikge1xuICAgIGNsZWFySW50ZXJ2YWwocmVmcmVzaFRpbWVyKTtcbiAgICByZWZyZXNoVGltZXIgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU3RhcnQgYXV0b21hdGljIHBlcm1pc3Npb24gc3luY1xuICogS2VlcHMgcGVybWlzc2lvbnMgZnJlc2ggd2l0aG91dCBkaXNydXB0aW5nIHVzZXIgZXhwZXJpZW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRQZXJtaXNzaW9uU3luYygpOiB2b2lkIHtcbiAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVyXG4gIGlmIChwZXJtaXNzaW9uU3luY1RpbWVyKSB7XG4gICAgY2xlYXJJbnRlcnZhbChwZXJtaXNzaW9uU3luY1RpbWVyKTtcbiAgfVxuXG4gIGNvbnN0IGNoZWNrQW5kU3luYyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlckRhdGEgPSBnZXRVc2VyRGF0YSgpO1xuICAgICAgaWYgKCF1c2VyRGF0YSkgcmV0dXJuO1xuXG4gICAgICAvLyBJZiBwZXJtaXNzaW9uIGNhY2hlIGlzIGludmFsaWQsIHN5bmMgcGVybWlzc2lvbnNcbiAgICAgIGlmICghaXNQZXJtaXNzaW9uQ2FjaGVWYWxpZCh1c2VyRGF0YS5pZCkpIHtcbiAgICAgICAgYXdhaXQgc3luY1Blcm1pc3Npb25zKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Blcm1pc3Npb24gc3luYyBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBTeW5jIGV2ZXJ5IDEwIG1pbnV0ZXNcbiAgcGVybWlzc2lvblN5bmNUaW1lciA9IHNldEludGVydmFsKGNoZWNrQW5kU3luYywgMTAgKiA2MCAqIDEwMDApO1xuXG4gIC8vIEFsc28gY2hlY2sgaW1tZWRpYXRlbHkgaWYgY2FjaGUgaXMgaW52YWxpZFxuICBjaGVja0FuZFN5bmMoKTtcbn1cblxuLyoqXG4gKiBTdG9wIGF1dG9tYXRpYyBwZXJtaXNzaW9uIHN5bmNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQZXJtaXNzaW9uU3luYygpOiB2b2lkIHtcbiAgaWYgKHBlcm1pc3Npb25TeW5jVGltZXIpIHtcbiAgICBjbGVhckludGVydmFsKHBlcm1pc3Npb25TeW5jVGltZXIpO1xuICAgIHBlcm1pc3Npb25TeW5jVGltZXIgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhdXRoIG1vbml0b3JpbmcgKHRva2VuIHJlZnJlc2ggKyBwZXJtaXNzaW9uIHN5bmMpXG4gKiBDYWxsIHRoaXMgd2hlbiB1c2VyIGxvZ3MgaW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVBdXRoTW9uaXRvcmluZygpOiB2b2lkIHtcbiAgc3RhcnRUb2tlblJlZnJlc2hNb25pdG9yKCk7XG4gIHN0YXJ0UGVybWlzc2lvblN5bmMoKTtcbn1cblxuLyoqXG4gKiBDbGVhbnVwIGF1dGggbW9uaXRvcmluZ1xuICogQ2FsbCB0aGlzIHdoZW4gdXNlciBsb2dzIG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cEF1dGhNb25pdG9yaW5nKCk6IHZvaWQge1xuICBzdG9wVG9rZW5SZWZyZXNoTW9uaXRvcigpO1xuICBzdG9wUGVybWlzc2lvblN5bmMoKTtcbiAgY2xlYXJQZXJtaXNzaW9uQ2FjaGUoKTtcbn1cblxuLyoqXG4gKiBHZXQgYXV0aGVudGljYXRpb24gc3RhdHVzIGZvciBkZWJ1Z2dpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dGhTdGF0dXMoKSB7XG4gIHJldHVybiB7XG4gICAgdG9rZW5FeHBpcmVkOiBpc1Rva2VuRXhwaXJlZCgpLFxuICAgIHNob3VsZFJlZnJlc2g6IHNob3VsZFJlZnJlc2hUb2tlbigpLFxuICAgIHRpbWVVbnRpbEV4cGlyeTogZ2V0VGltZVVudGlsRXhwaXJ5KCksXG4gICAgaGFzVG9rZW46ICEhZ2V0VG9rZW4oKSxcbiAgICBoYXNVc2VyRGF0YTogISFnZXRVc2VyRGF0YSgpLFxuICAgIG1vbml0b3JpbmdBY3RpdmU6ICEhcmVmcmVzaFRpbWVyLFxuICAgIHN5bmNBY3RpdmU6ICEhcGVybWlzc2lvblN5bmNUaW1lcixcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRUb2tlbiIsInN0b3JlVG9rZW4iLCJzaG91bGRSZWZyZXNoVG9rZW4iLCJpc1Rva2VuRXhwaXJlZCIsImdldFRpbWVVbnRpbEV4cGlyeSIsImdldFVzZXJEYXRhIiwic3RvcmVVc2VyRGF0YSIsImlzUGVybWlzc2lvbkNhY2hlVmFsaWQiLCJjbGVhclBlcm1pc3Npb25DYWNoZSIsImFwaUNhbGwiLCJyZWZyZXNoUHJvbWlzZSIsInJlZnJlc2hUaW1lciIsInBlcm1pc3Npb25TeW5jVGltZXIiLCJyZWZyZXNoQXV0aFRva2VuIiwiZGF0YSIsImN1cnJlbnRUb2tlbiIsIkVycm9yIiwicmVzcG9uc2UiLCJmZXRjaCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwibWV0aG9kIiwiaGVhZGVycyIsIm9rIiwianNvbiIsInRva2VuIiwiZXJyb3IiLCJjb25zb2xlIiwic3luY1Blcm1pc3Npb25zIiwidXNlckRhdGEiLCJpZCIsInVuZGVmaW5lZCIsInN0YXR1cyIsInVzZXIiLCJkZWJ1ZyIsInN0YXJ0VG9rZW5SZWZyZXNoTW9uaXRvciIsImNsZWFySW50ZXJ2YWwiLCJjaGVja0FuZFJlZnJlc2giLCJzdG9wVG9rZW5SZWZyZXNoTW9uaXRvciIsInNldEludGVydmFsIiwic3RhcnRQZXJtaXNzaW9uU3luYyIsImNoZWNrQW5kU3luYyIsInN0b3BQZXJtaXNzaW9uU3luYyIsImluaXRpYWxpemVBdXRoTW9uaXRvcmluZyIsImNsZWFudXBBdXRoTW9uaXRvcmluZyIsImdldEF1dGhTdGF0dXMiLCJ0b2tlbkV4cGlyZWQiLCJzaG91bGRSZWZyZXNoIiwidGltZVVudGlsRXhwaXJ5IiwiaGFzVG9rZW4iLCJoYXNVc2VyRGF0YSIsIm1vbml0b3JpbmdBY3RpdmUiLCJzeW5jQWN0aXZlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth-refresh.ts\n"));

/***/ })

});