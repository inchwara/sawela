"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/sign-in/[[...sign-in]]/page",{

/***/ "(app-pages-browser)/./lib/auth-refresh.ts":
/*!*****************************!*\
  !*** ./lib/auth-refresh.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupAuthMonitoring: () => (/* binding */ cleanupAuthMonitoring),\n/* harmony export */   getAuthStatus: () => (/* binding */ getAuthStatus),\n/* harmony export */   initializeAuthMonitoring: () => (/* binding */ initializeAuthMonitoring),\n/* harmony export */   refreshAuthToken: () => (/* binding */ refreshAuthToken),\n/* harmony export */   startPermissionSync: () => (/* binding */ startPermissionSync),\n/* harmony export */   startTokenRefreshMonitor: () => (/* binding */ startTokenRefreshMonitor),\n/* harmony export */   stopPermissionSync: () => (/* binding */ stopPermissionSync),\n/* harmony export */   stopTokenRefreshMonitor: () => (/* binding */ stopTokenRefreshMonitor),\n/* harmony export */   syncPermissions: () => (/* binding */ syncPermissions)\n/* harmony export */ });\n/* harmony import */ var _token_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./token-manager */ \"(app-pages-browser)/./lib/token-manager.ts\");\n/* harmony import */ var _permission_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./permission-manager */ \"(app-pages-browser)/./lib/permission-manager.ts\");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api */ \"(app-pages-browser)/./lib/api.ts\");\n/**\n * Auth Refresh Service\n * Handles automatic token refresh and permission sync\n */ \n\n\nlet refreshPromise = null;\nlet refreshTimer = null;\nlet permissionSyncTimer = null;\n/**\n * Refresh the authentication token\n * Returns a promise that resolves to the new token\n */ async function refreshAuthToken() {\n    // If a refresh is already in progress, return that promise\n    if (refreshPromise) {\n        return refreshPromise;\n    }\n    refreshPromise = (async ()=>{\n        try {\n            var _data_data;\n            const currentToken = (0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.getToken)();\n            if (!currentToken) {\n                throw new Error('No token to refresh');\n            }\n            // Call the refresh endpoint (adjust endpoint as needed)\n            // Note: If your API doesn't have a refresh endpoint, this will fetch user profile instead\n            const response = await fetch(\"\".concat(\"http://localhost:8000/api\" || 0, \"/user\"), {\n                method: 'GET',\n                headers: {\n                    'Authorization': \"Bearer \".concat(currentToken),\n                    'Accept': 'application/json'\n                }\n            });\n            if (!response.ok) {\n                throw new Error('Token refresh failed');\n            }\n            const data = await response.json();\n            // If the API returns a new token, store it\n            // Otherwise, the token is still valid (Sanctum tokens don't expire by default)\n            if ((_data_data = data.data) === null || _data_data === void 0 ? void 0 : _data_data.token) {\n                (0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.storeToken)(data.data.token);\n                return data.data.token;\n            }\n            // If no new token, the current one is still valid\n            return currentToken;\n        } catch (error) {\n            console.error('Token refresh failed:', error);\n            throw error;\n        } finally{\n            refreshPromise = null;\n        }\n    })();\n    return refreshPromise;\n}\n/**\n * Sync permissions from the server\n */ async function syncPermissions() {\n    try {\n        var _response_data;\n        const userData = (0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.getUserData)();\n        if (!userData) return;\n        // Fetch fresh user data including permissions\n        const response = await (0,_api__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('/user', 'GET', undefined, true);\n        if (response.status === 'success' && ((_response_data = response.data) === null || _response_data === void 0 ? void 0 : _response_data.user)) {\n            // Update user data with fresh permissions\n            (0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.storeUserData)(response.data.user);\n        }\n    } catch (error) {\n        console.error('Permission sync failed:', error);\n    }\n}\n/**\n * Start automatic token refresh\n * Monitors token expiration and refreshes proactively\n */ function startTokenRefreshMonitor() {\n    // Clear any existing timer\n    if (refreshTimer) {\n        clearInterval(refreshTimer);\n    }\n    const checkAndRefresh = async ()=>{\n        try {\n            // If token is expired, trigger logout (handled by auth context)\n            if ((0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.isTokenExpired)()) {\n                stopTokenRefreshMonitor();\n                return;\n            }\n            // If token should be refreshed (within threshold), refresh it\n            if ((0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.shouldRefreshToken)()) {\n                await refreshAuthToken();\n            }\n        } catch (error) {\n            console.error('Token refresh check failed:', error);\n        }\n    };\n    // Check every 2 minutes\n    refreshTimer = setInterval(checkAndRefresh, 2 * 60 * 1000);\n    // Also check immediately\n    checkAndRefresh();\n}\n/**\n * Stop automatic token refresh\n */ function stopTokenRefreshMonitor() {\n    if (refreshTimer) {\n        clearInterval(refreshTimer);\n        refreshTimer = null;\n    }\n}\n/**\n * Start automatic permission sync\n * Keeps permissions fresh without disrupting user experience\n */ function startPermissionSync() {\n    // Clear any existing timer\n    if (permissionSyncTimer) {\n        clearInterval(permissionSyncTimer);\n    }\n    const checkAndSync = async ()=>{\n        try {\n            const userData = (0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.getUserData)();\n            if (!userData) return;\n            // If permission cache is invalid, sync permissions\n            if (!(0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.isPermissionCacheValid)(userData.id)) {\n                await syncPermissions();\n            }\n        } catch (error) {\n            console.error('Permission sync check failed:', error);\n        }\n    };\n    // Sync every 10 minutes\n    permissionSyncTimer = setInterval(checkAndSync, 10 * 60 * 1000);\n    // Also check immediately if cache is invalid\n    checkAndSync();\n}\n/**\n * Stop automatic permission sync\n */ function stopPermissionSync() {\n    if (permissionSyncTimer) {\n        clearInterval(permissionSyncTimer);\n        permissionSyncTimer = null;\n    }\n}\n/**\n * Initialize auth monitoring (token refresh + permission sync)\n * Call this when user logs in\n */ function initializeAuthMonitoring() {\n    startTokenRefreshMonitor();\n    startPermissionSync();\n}\n/**\n * Cleanup auth monitoring\n * Call this when user logs out\n */ function cleanupAuthMonitoring() {\n    stopTokenRefreshMonitor();\n    stopPermissionSync();\n    (0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.clearPermissionCache)();\n}\n/**\n * Get authentication status for debugging\n */ function getAuthStatus() {\n    return {\n        tokenExpired: (0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.isTokenExpired)(),\n        shouldRefresh: (0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.shouldRefreshToken)(),\n        timeUntilExpiry: (0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.getTimeUntilExpiry)(),\n        hasToken: !!(0,_token_manager__WEBPACK_IMPORTED_MODULE_0__.getToken)(),\n        hasUserData: !!(0,_permission_manager__WEBPACK_IMPORTED_MODULE_1__.getUserData)(),\n        monitoringActive: !!refreshTimer,\n        syncActive: !!permissionSyncTimer\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hdXRoLXJlZnJlc2gudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBRThHO0FBQ0M7QUFDcEY7QUFXNUIsSUFBSVUsaUJBQXlDO0FBQzdDLElBQUlDLGVBQXNDO0FBQzFDLElBQUlDLHNCQUE2QztBQUVqRDs7O0NBR0MsR0FDTSxlQUFlQztJQUNwQiwyREFBMkQ7SUFDM0QsSUFBSUgsZ0JBQWdCO1FBQ2xCLE9BQU9BO0lBQ1Q7SUFFQUEsaUJBQWlCLENBQUM7UUFDaEIsSUFBSTtnQkF3QkVJO1lBdkJKLE1BQU1DLGVBQWVmLHdEQUFRQTtZQUM3QixJQUFJLENBQUNlLGNBQWM7Z0JBQ2pCLE1BQU0sSUFBSUMsTUFBTTtZQUNsQjtZQUVBLHdEQUF3RDtZQUN4RCwwRkFBMEY7WUFDMUYsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLEdBQWtFLE9BQS9EQywyQkFBK0IsSUFBSSxDQUEyQixFQUFDLFVBQVE7Z0JBQ3JHRyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGlCQUFpQixVQUF1QixPQUFiUjtvQkFDM0IsVUFBVTtnQkFDWjtZQUNGO1lBRUEsSUFBSSxDQUFDRSxTQUFTTyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSVIsTUFBTTtZQUNsQjtZQUVBLE1BQU1GLE9BQU8sTUFBTUcsU0FBU1EsSUFBSTtZQUVoQywyQ0FBMkM7WUFDM0MsK0VBQStFO1lBQy9FLEtBQUlYLGFBQUFBLEtBQUtBLElBQUksY0FBVEEsaUNBQUFBLFdBQVdZLEtBQUssRUFBRTtnQkFDcEJ6QiwwREFBVUEsQ0FBQ2EsS0FBS0EsSUFBSSxDQUFDWSxLQUFLO2dCQUMxQixPQUFPWixLQUFLQSxJQUFJLENBQUNZLEtBQUs7WUFDeEI7WUFFQSxrREFBa0Q7WUFDbEQsT0FBT1g7UUFDVCxFQUFFLE9BQU9ZLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsTUFBTUE7UUFDUixTQUFVO1lBQ1JqQixpQkFBaUI7UUFDbkI7SUFDRjtJQUVBLE9BQU9BO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLGVBQWVtQjtJQUNwQixJQUFJO1lBT21DWjtRQU5yQyxNQUFNYSxXQUFXekIsZ0VBQVdBO1FBQzVCLElBQUksQ0FBQ3lCLFVBQVU7UUFFZiw4Q0FBOEM7UUFDOUMsTUFBTWIsV0FBVyxNQUFNUixnREFBT0EsQ0FBa0IsU0FBUyxPQUFPc0IsV0FBVztRQUUzRSxJQUFJZCxTQUFTZSxNQUFNLEtBQUssZUFBYWYsaUJBQUFBLFNBQVNILElBQUksY0FBYkcscUNBQUFBLGVBQWVnQixJQUFJLEdBQUU7WUFDeEQsMENBQTBDO1lBQzFDM0Isa0VBQWFBLENBQUNXLFNBQVNILElBQUksQ0FBQ21CLElBQUk7UUFDbEM7SUFDRixFQUFFLE9BQU9OLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDJCQUEyQkE7SUFDM0M7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNPO0lBQ2QsMkJBQTJCO0lBQzNCLElBQUl2QixjQUFjO1FBQ2hCd0IsY0FBY3hCO0lBQ2hCO0lBRUEsTUFBTXlCLGtCQUFrQjtRQUN0QixJQUFJO1lBQ0YsZ0VBQWdFO1lBQ2hFLElBQUlqQyw4REFBY0EsSUFBSTtnQkFDcEJrQztnQkFDQTtZQUNGO1lBRUEsOERBQThEO1lBQzlELElBQUluQyxrRUFBa0JBLElBQUk7Z0JBQ3hCLE1BQU1XO1lBQ1I7UUFDRixFQUFFLE9BQU9jLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLCtCQUErQkE7UUFDL0M7SUFDRjtJQUVBLHdCQUF3QjtJQUN4QmhCLGVBQWUyQixZQUFZRixpQkFBaUIsSUFBSSxLQUFLO0lBRXJELHlCQUF5QjtJQUN6QkE7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0M7SUFDZCxJQUFJMUIsY0FBYztRQUNoQndCLGNBQWN4QjtRQUNkQSxlQUFlO0lBQ2pCO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxTQUFTNEI7SUFDZCwyQkFBMkI7SUFDM0IsSUFBSTNCLHFCQUFxQjtRQUN2QnVCLGNBQWN2QjtJQUNoQjtJQUVBLE1BQU00QixlQUFlO1FBQ25CLElBQUk7WUFDRixNQUFNVixXQUFXekIsZ0VBQVdBO1lBQzVCLElBQUksQ0FBQ3lCLFVBQVU7WUFFZixtREFBbUQ7WUFDbkQsSUFBSSxDQUFDdkIsMkVBQXNCQSxDQUFDdUIsU0FBU1csRUFBRSxHQUFHO2dCQUN4QyxNQUFNWjtZQUNSO1FBQ0YsRUFBRSxPQUFPRixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1FBQ2pEO0lBQ0Y7SUFFQSx3QkFBd0I7SUFDeEJmLHNCQUFzQjBCLFlBQVlFLGNBQWMsS0FBSyxLQUFLO0lBRTFELDZDQUE2QztJQUM3Q0E7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0U7SUFDZCxJQUFJOUIscUJBQXFCO1FBQ3ZCdUIsY0FBY3ZCO1FBQ2RBLHNCQUFzQjtJQUN4QjtBQUNGO0FBRUE7OztDQUdDLEdBQ00sU0FBUytCO0lBQ2RUO0lBQ0FLO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxTQUFTSztJQUNkUDtJQUNBSztJQUNBbEMseUVBQW9CQTtBQUN0QjtBQUVBOztDQUVDLEdBQ00sU0FBU3FDO0lBQ2QsT0FBTztRQUNMQyxjQUFjM0MsOERBQWNBO1FBQzVCNEMsZUFBZTdDLGtFQUFrQkE7UUFDakM4QyxpQkFBaUI1QyxrRUFBa0JBO1FBQ25DNkMsVUFBVSxDQUFDLENBQUNqRCx3REFBUUE7UUFDcEJrRCxhQUFhLENBQUMsQ0FBQzdDLGdFQUFXQTtRQUMxQjhDLGtCQUFrQixDQUFDLENBQUN4QztRQUNwQnlDLFlBQVksQ0FBQyxDQUFDeEM7SUFDaEI7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2luY2h3YXJhL3Nhd2VsYS9saWIvYXV0aC1yZWZyZXNoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXV0aCBSZWZyZXNoIFNlcnZpY2VcbiAqIEhhbmRsZXMgYXV0b21hdGljIHRva2VuIHJlZnJlc2ggYW5kIHBlcm1pc3Npb24gc3luY1xuICovXG5cbmltcG9ydCB7IGdldFRva2VuLCBzdG9yZVRva2VuLCBzaG91bGRSZWZyZXNoVG9rZW4sIGlzVG9rZW5FeHBpcmVkLCBnZXRUaW1lVW50aWxFeHBpcnkgfSBmcm9tICcuL3Rva2VuLW1hbmFnZXInO1xuaW1wb3J0IHsgZ2V0VXNlckRhdGEsIHN0b3JlVXNlckRhdGEsIGlzUGVybWlzc2lvbkNhY2hlVmFsaWQsIGNsZWFyUGVybWlzc2lvbkNhY2hlIH0gZnJvbSAnLi9wZXJtaXNzaW9uLW1hbmFnZXInO1xuaW1wb3J0IGFwaUNhbGwgZnJvbSAnLi9hcGknO1xuXG5pbnRlcmZhY2UgUmVmcmVzaFJlc3BvbnNlIHtcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgZGF0YToge1xuICAgIHRva2VuOiBzdHJpbmc7XG4gICAgdXNlcjogYW55O1xuICB9O1xufVxuXG5sZXQgcmVmcmVzaFByb21pc2U6IFByb21pc2U8c3RyaW5nPiB8IG51bGwgPSBudWxsO1xubGV0IHJlZnJlc2hUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcbmxldCBwZXJtaXNzaW9uU3luY1RpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuXG4vKipcbiAqIFJlZnJlc2ggdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgdG9rZW5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hBdXRoVG9rZW4oKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgLy8gSWYgYSByZWZyZXNoIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHJldHVybiB0aGF0IHByb21pc2VcbiAgaWYgKHJlZnJlc2hQcm9taXNlKSB7XG4gICAgcmV0dXJuIHJlZnJlc2hQcm9taXNlO1xuICB9XG5cbiAgcmVmcmVzaFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50VG9rZW4gPSBnZXRUb2tlbigpO1xuICAgICAgaWYgKCFjdXJyZW50VG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0b2tlbiB0byByZWZyZXNoJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGwgdGhlIHJlZnJlc2ggZW5kcG9pbnQgKGFkanVzdCBlbmRwb2ludCBhcyBuZWVkZWQpXG4gICAgICAvLyBOb3RlOiBJZiB5b3VyIEFQSSBkb2Vzbid0IGhhdmUgYSByZWZyZXNoIGVuZHBvaW50LCB0aGlzIHdpbGwgZmV0Y2ggdXNlciBwcm9maWxlIGluc3RlYWRcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaSd9L3VzZXJgLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtjdXJyZW50VG9rZW59YCxcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIC8vIElmIHRoZSBBUEkgcmV0dXJucyBhIG5ldyB0b2tlbiwgc3RvcmUgaXRcbiAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHRva2VuIGlzIHN0aWxsIHZhbGlkIChTYW5jdHVtIHRva2VucyBkb24ndCBleHBpcmUgYnkgZGVmYXVsdClcbiAgICAgIGlmIChkYXRhLmRhdGE/LnRva2VuKSB7XG4gICAgICAgIHN0b3JlVG9rZW4oZGF0YS5kYXRhLnRva2VuKTtcbiAgICAgICAgcmV0dXJuIGRhdGEuZGF0YS50b2tlbjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gbmV3IHRva2VuLCB0aGUgY3VycmVudCBvbmUgaXMgc3RpbGwgdmFsaWRcbiAgICAgIHJldHVybiBjdXJyZW50VG9rZW47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Rva2VuIHJlZnJlc2ggZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZWZyZXNoUHJvbWlzZSA9IG51bGw7XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiByZWZyZXNoUHJvbWlzZTtcbn1cblxuLyoqXG4gKiBTeW5jIHBlcm1pc3Npb25zIGZyb20gdGhlIHNlcnZlclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3luY1Blcm1pc3Npb25zKCk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXJEYXRhID0gZ2V0VXNlckRhdGEoKTtcbiAgICBpZiAoIXVzZXJEYXRhKSByZXR1cm47XG5cbiAgICAvLyBGZXRjaCBmcmVzaCB1c2VyIGRhdGEgaW5jbHVkaW5nIHBlcm1pc3Npb25zXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsPFJlZnJlc2hSZXNwb25zZT4oJy91c2VyJywgJ0dFVCcsIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAnc3VjY2VzcycgJiYgcmVzcG9uc2UuZGF0YT8udXNlcikge1xuICAgICAgLy8gVXBkYXRlIHVzZXIgZGF0YSB3aXRoIGZyZXNoIHBlcm1pc3Npb25zXG4gICAgICBzdG9yZVVzZXJEYXRhKHJlc3BvbnNlLmRhdGEudXNlcik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1Blcm1pc3Npb24gc3luYyBmYWlsZWQ6JywgZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogU3RhcnQgYXV0b21hdGljIHRva2VuIHJlZnJlc2hcbiAqIE1vbml0b3JzIHRva2VuIGV4cGlyYXRpb24gYW5kIHJlZnJlc2hlcyBwcm9hY3RpdmVseVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRUb2tlblJlZnJlc2hNb25pdG9yKCk6IHZvaWQge1xuICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZXJcbiAgaWYgKHJlZnJlc2hUaW1lcikge1xuICAgIGNsZWFySW50ZXJ2YWwocmVmcmVzaFRpbWVyKTtcbiAgfVxuXG4gIGNvbnN0IGNoZWNrQW5kUmVmcmVzaCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSWYgdG9rZW4gaXMgZXhwaXJlZCwgdHJpZ2dlciBsb2dvdXQgKGhhbmRsZWQgYnkgYXV0aCBjb250ZXh0KVxuICAgICAgaWYgKGlzVG9rZW5FeHBpcmVkKCkpIHtcbiAgICAgICAgc3RvcFRva2VuUmVmcmVzaE1vbml0b3IoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0b2tlbiBzaG91bGQgYmUgcmVmcmVzaGVkICh3aXRoaW4gdGhyZXNob2xkKSwgcmVmcmVzaCBpdFxuICAgICAgaWYgKHNob3VsZFJlZnJlc2hUb2tlbigpKSB7XG4gICAgICAgIGF3YWl0IHJlZnJlc2hBdXRoVG9rZW4oKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVG9rZW4gcmVmcmVzaCBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDaGVjayBldmVyeSAyIG1pbnV0ZXNcbiAgcmVmcmVzaFRpbWVyID0gc2V0SW50ZXJ2YWwoY2hlY2tBbmRSZWZyZXNoLCAyICogNjAgKiAxMDAwKTtcblxuICAvLyBBbHNvIGNoZWNrIGltbWVkaWF0ZWx5XG4gIGNoZWNrQW5kUmVmcmVzaCgpO1xufVxuXG4vKipcbiAqIFN0b3AgYXV0b21hdGljIHRva2VuIHJlZnJlc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3BUb2tlblJlZnJlc2hNb25pdG9yKCk6IHZvaWQge1xuICBpZiAocmVmcmVzaFRpbWVyKSB7XG4gICAgY2xlYXJJbnRlcnZhbChyZWZyZXNoVGltZXIpO1xuICAgIHJlZnJlc2hUaW1lciA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTdGFydCBhdXRvbWF0aWMgcGVybWlzc2lvbiBzeW5jXG4gKiBLZWVwcyBwZXJtaXNzaW9ucyBmcmVzaCB3aXRob3V0IGRpc3J1cHRpbmcgdXNlciBleHBlcmllbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFBlcm1pc3Npb25TeW5jKCk6IHZvaWQge1xuICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdGltZXJcbiAgaWYgKHBlcm1pc3Npb25TeW5jVGltZXIpIHtcbiAgICBjbGVhckludGVydmFsKHBlcm1pc3Npb25TeW5jVGltZXIpO1xuICB9XG5cbiAgY29uc3QgY2hlY2tBbmRTeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGdldFVzZXJEYXRhKCk7XG4gICAgICBpZiAoIXVzZXJEYXRhKSByZXR1cm47XG5cbiAgICAgIC8vIElmIHBlcm1pc3Npb24gY2FjaGUgaXMgaW52YWxpZCwgc3luYyBwZXJtaXNzaW9uc1xuICAgICAgaWYgKCFpc1Blcm1pc3Npb25DYWNoZVZhbGlkKHVzZXJEYXRhLmlkKSkge1xuICAgICAgICBhd2FpdCBzeW5jUGVybWlzc2lvbnMoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignUGVybWlzc2lvbiBzeW5jIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIFN5bmMgZXZlcnkgMTAgbWludXRlc1xuICBwZXJtaXNzaW9uU3luY1RpbWVyID0gc2V0SW50ZXJ2YWwoY2hlY2tBbmRTeW5jLCAxMCAqIDYwICogMTAwMCk7XG5cbiAgLy8gQWxzbyBjaGVjayBpbW1lZGlhdGVseSBpZiBjYWNoZSBpcyBpbnZhbGlkXG4gIGNoZWNrQW5kU3luYygpO1xufVxuXG4vKipcbiAqIFN0b3AgYXV0b21hdGljIHBlcm1pc3Npb24gc3luY1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcFBlcm1pc3Npb25TeW5jKCk6IHZvaWQge1xuICBpZiAocGVybWlzc2lvblN5bmNUaW1lcikge1xuICAgIGNsZWFySW50ZXJ2YWwocGVybWlzc2lvblN5bmNUaW1lcik7XG4gICAgcGVybWlzc2lvblN5bmNUaW1lciA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGF1dGggbW9uaXRvcmluZyAodG9rZW4gcmVmcmVzaCArIHBlcm1pc3Npb24gc3luYylcbiAqIENhbGwgdGhpcyB3aGVuIHVzZXIgbG9ncyBpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUF1dGhNb25pdG9yaW5nKCk6IHZvaWQge1xuICBzdGFydFRva2VuUmVmcmVzaE1vbml0b3IoKTtcbiAgc3RhcnRQZXJtaXNzaW9uU3luYygpO1xufVxuXG4vKipcbiAqIENsZWFudXAgYXV0aCBtb25pdG9yaW5nXG4gKiBDYWxsIHRoaXMgd2hlbiB1c2VyIGxvZ3Mgb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwQXV0aE1vbml0b3JpbmcoKTogdm9pZCB7XG4gIHN0b3BUb2tlblJlZnJlc2hNb25pdG9yKCk7XG4gIHN0b3BQZXJtaXNzaW9uU3luYygpO1xuICBjbGVhclBlcm1pc3Npb25DYWNoZSgpO1xufVxuXG4vKipcbiAqIEdldCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgZm9yIGRlYnVnZ2luZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXV0aFN0YXR1cygpIHtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbkV4cGlyZWQ6IGlzVG9rZW5FeHBpcmVkKCksXG4gICAgc2hvdWxkUmVmcmVzaDogc2hvdWxkUmVmcmVzaFRva2VuKCksXG4gICAgdGltZVVudGlsRXhwaXJ5OiBnZXRUaW1lVW50aWxFeHBpcnkoKSxcbiAgICBoYXNUb2tlbjogISFnZXRUb2tlbigpLFxuICAgIGhhc1VzZXJEYXRhOiAhIWdldFVzZXJEYXRhKCksXG4gICAgbW9uaXRvcmluZ0FjdGl2ZTogISFyZWZyZXNoVGltZXIsXG4gICAgc3luY0FjdGl2ZTogISFwZXJtaXNzaW9uU3luY1RpbWVyLFxuICB9O1xufVxuIl0sIm5hbWVzIjpbImdldFRva2VuIiwic3RvcmVUb2tlbiIsInNob3VsZFJlZnJlc2hUb2tlbiIsImlzVG9rZW5FeHBpcmVkIiwiZ2V0VGltZVVudGlsRXhwaXJ5IiwiZ2V0VXNlckRhdGEiLCJzdG9yZVVzZXJEYXRhIiwiaXNQZXJtaXNzaW9uQ2FjaGVWYWxpZCIsImNsZWFyUGVybWlzc2lvbkNhY2hlIiwiYXBpQ2FsbCIsInJlZnJlc2hQcm9taXNlIiwicmVmcmVzaFRpbWVyIiwicGVybWlzc2lvblN5bmNUaW1lciIsInJlZnJlc2hBdXRoVG9rZW4iLCJkYXRhIiwiY3VycmVudFRva2VuIiwiRXJyb3IiLCJyZXNwb25zZSIsImZldGNoIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJtZXRob2QiLCJoZWFkZXJzIiwib2siLCJqc29uIiwidG9rZW4iLCJlcnJvciIsImNvbnNvbGUiLCJzeW5jUGVybWlzc2lvbnMiLCJ1c2VyRGF0YSIsInVuZGVmaW5lZCIsInN0YXR1cyIsInVzZXIiLCJzdGFydFRva2VuUmVmcmVzaE1vbml0b3IiLCJjbGVhckludGVydmFsIiwiY2hlY2tBbmRSZWZyZXNoIiwic3RvcFRva2VuUmVmcmVzaE1vbml0b3IiLCJzZXRJbnRlcnZhbCIsInN0YXJ0UGVybWlzc2lvblN5bmMiLCJjaGVja0FuZFN5bmMiLCJpZCIsInN0b3BQZXJtaXNzaW9uU3luYyIsImluaXRpYWxpemVBdXRoTW9uaXRvcmluZyIsImNsZWFudXBBdXRoTW9uaXRvcmluZyIsImdldEF1dGhTdGF0dXMiLCJ0b2tlbkV4cGlyZWQiLCJzaG91bGRSZWZyZXNoIiwidGltZVVudGlsRXhwaXJ5IiwiaGFzVG9rZW4iLCJoYXNVc2VyRGF0YSIsIm1vbml0b3JpbmdBY3RpdmUiLCJzeW5jQWN0aXZlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth-refresh.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/config.ts":
/*!***********************!*\
  !*** ./lib/config.ts ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   getApiUrl: () => (/* binding */ getApiUrl),\n/* harmony export */   getAppUrl: () => (/* binding */ getAppUrl)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Environment configuration utility\nconst config = {\n    // API Configuration\n    api: {\n        baseUrl: \"http://localhost:8000/api\",\n        appUrl: \"http://localhost:3000\" || 0\n    },\n    // Email Configuration\n    email: {\n        resendApiKey: process.env.RESEND_API_KEY\n    },\n    // WhatsApp Configuration\n    whatsapp: {\n        apiUrl: process.env.WHATSAPP_API_URL || \"https://graph.facebook.com/v21.0\",\n        apiToken: process.env.WHATSAPP_API_TOKEN,\n        phoneNumberId: process.env.WHATSAPP_PHONE_NUMBER_ID,\n        accessToken: process.env.WHATSAPP_ACCESS_TOKEN,\n        businessAccountId: process.env.WHATSAPP_BUSINESS_ACCOUNT_ID,\n        catalogId: process.env.WHATSAPP_CATALOG_ID\n    },\n    // Environment detection\n    isDevelopment: \"development\" === 'development',\n    isProduction: \"development\" === 'production',\n    isTest: \"development\" === 'test'\n};\n// Helper function to get environment-specific API URL\nconst getApiUrl = function() {\n    let path = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '';\n    const baseUrl = config.api.baseUrl;\n    console.log(\"API Base URL: \".concat(baseUrl, \", Path: \").concat(path));\n    return \"\".concat(baseUrl).concat(path);\n};\n// Helper function to get app URL\nconst getAppUrl = function() {\n    let path = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '';\n    return \"\".concat(config.api.appUrl).concat(path);\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jb25maWcudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLG9DQUFvQztBQUM3QixNQUFNQSxTQUFTO0lBQ3BCLG9CQUFvQjtJQUNwQkMsS0FBSztRQUNIQyxTQUFTQywyQkFBK0I7UUFDeENHLFFBQVFILHVCQUErQixJQUFJLENBQXVCO0lBQ3BFO0lBRUEsc0JBQXNCO0lBQ3RCSyxPQUFPO1FBQ0xDLGNBQWNOLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ00sY0FBYztJQUMxQztJQUVBLHlCQUF5QjtJQUN6QkMsVUFBVTtRQUNSQyxRQUFRVCxPQUFPQSxDQUFDQyxHQUFHLENBQUNTLGdCQUFnQixJQUFJO1FBQ3hDQyxVQUFVWCxPQUFPQSxDQUFDQyxHQUFHLENBQUNXLGtCQUFrQjtRQUN4Q0MsZUFBZWIsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDYSx3QkFBd0I7UUFDbkRDLGFBQWFmLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ2UscUJBQXFCO1FBQzlDQyxtQkFBbUJqQixPQUFPQSxDQUFDQyxHQUFHLENBQUNpQiw0QkFBNEI7UUFDM0RDLFdBQVduQixPQUFPQSxDQUFDQyxHQUFHLENBQUNtQixtQkFBbUI7SUFDNUM7SUFFQSx3QkFBd0I7SUFDeEJDLGVBQWVyQixrQkFBeUI7SUFDeENzQixjQUFjdEIsa0JBQXlCO0lBQ3ZDdUIsUUFBUXZCLGtCQUF5QjtBQUNuQyxFQUFDO0FBRUQsc0RBQXNEO0FBQy9DLE1BQU13QixZQUFZO1FBQUNDLHdFQUFlO0lBQ3ZDLE1BQU0xQixVQUFVRixPQUFPQyxHQUFHLENBQUNDLE9BQU87SUFDbEMyQixRQUFRQyxHQUFHLENBQUMsaUJBQW1DRixPQUFsQjFCLFNBQVEsWUFBZSxPQUFMMEI7SUFDL0MsT0FBTyxHQUFhQSxPQUFWMUIsU0FBZSxPQUFMMEI7QUFDdEIsRUFBQztBQUVELGlDQUFpQztBQUMxQixNQUFNRyxZQUFZO1FBQUNILHdFQUFlO0lBQ3ZDLE9BQU8sR0FBdUJBLE9BQXBCNUIsT0FBT0MsR0FBRyxDQUFDSyxNQUFNLEVBQVEsT0FBTHNCO0FBQ2hDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pbmNod2FyYS9zYXdlbGEvbGliL2NvbmZpZy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnZpcm9ubWVudCBjb25maWd1cmF0aW9uIHV0aWxpdHlcbmV4cG9ydCBjb25zdCBjb25maWcgPSB7XG4gIC8vIEFQSSBDb25maWd1cmF0aW9uXG4gIGFwaToge1xuICAgIGJhc2VVcmw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwsXG4gICAgYXBwVXJsOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUFBfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCIsXG4gIH0sXG4gIFxuICAvLyBFbWFpbCBDb25maWd1cmF0aW9uXG4gIGVtYWlsOiB7XG4gICAgcmVzZW5kQXBpS2V5OiBwcm9jZXNzLmVudi5SRVNFTkRfQVBJX0tFWSxcbiAgfSxcbiAgXG4gIC8vIFdoYXRzQXBwIENvbmZpZ3VyYXRpb25cbiAgd2hhdHNhcHA6IHtcbiAgICBhcGlVcmw6IHByb2Nlc3MuZW52LldIQVRTQVBQX0FQSV9VUkwgfHwgXCJodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS92MjEuMFwiLFxuICAgIGFwaVRva2VuOiBwcm9jZXNzLmVudi5XSEFUU0FQUF9BUElfVE9LRU4sXG4gICAgcGhvbmVOdW1iZXJJZDogcHJvY2Vzcy5lbnYuV0hBVFNBUFBfUEhPTkVfTlVNQkVSX0lELFxuICAgIGFjY2Vzc1Rva2VuOiBwcm9jZXNzLmVudi5XSEFUU0FQUF9BQ0NFU1NfVE9LRU4sXG4gICAgYnVzaW5lc3NBY2NvdW50SWQ6IHByb2Nlc3MuZW52LldIQVRTQVBQX0JVU0lORVNTX0FDQ09VTlRfSUQsXG4gICAgY2F0YWxvZ0lkOiBwcm9jZXNzLmVudi5XSEFUU0FQUF9DQVRBTE9HX0lELFxuICB9LFxuICBcbiAgLy8gRW52aXJvbm1lbnQgZGV0ZWN0aW9uXG4gIGlzRGV2ZWxvcG1lbnQ6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnLFxuICBpc1Byb2R1Y3Rpb246IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicsXG4gIGlzVGVzdDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jyxcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBlbnZpcm9ubWVudC1zcGVjaWZpYyBBUEkgVVJMXG5leHBvcnQgY29uc3QgZ2V0QXBpVXJsID0gKHBhdGg6IHN0cmluZyA9ICcnKSA9PiB7XG4gIGNvbnN0IGJhc2VVcmwgPSBjb25maWcuYXBpLmJhc2VVcmw7XG4gIGNvbnNvbGUubG9nKGBBUEkgQmFzZSBVUkw6ICR7YmFzZVVybH0sIFBhdGg6ICR7cGF0aH1gKTtcbiAgcmV0dXJuIGAke2Jhc2VVcmx9JHtwYXRofWBcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhcHAgVVJMXG5leHBvcnQgY29uc3QgZ2V0QXBwVXJsID0gKHBhdGg6IHN0cmluZyA9ICcnKSA9PiB7XG4gIHJldHVybiBgJHtjb25maWcuYXBpLmFwcFVybH0ke3BhdGh9YFxufSJdLCJuYW1lcyI6WyJjb25maWciLCJhcGkiLCJiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJhcHBVcmwiLCJORVhUX1BVQkxJQ19BUFBfVVJMIiwiZW1haWwiLCJyZXNlbmRBcGlLZXkiLCJSRVNFTkRfQVBJX0tFWSIsIndoYXRzYXBwIiwiYXBpVXJsIiwiV0hBVFNBUFBfQVBJX1VSTCIsImFwaVRva2VuIiwiV0hBVFNBUFBfQVBJX1RPS0VOIiwicGhvbmVOdW1iZXJJZCIsIldIQVRTQVBQX1BIT05FX05VTUJFUl9JRCIsImFjY2Vzc1Rva2VuIiwiV0hBVFNBUFBfQUNDRVNTX1RPS0VOIiwiYnVzaW5lc3NBY2NvdW50SWQiLCJXSEFUU0FQUF9CVVNJTkVTU19BQ0NPVU5UX0lEIiwiY2F0YWxvZ0lkIiwiV0hBVFNBUFBfQ0FUQUxPR19JRCIsImlzRGV2ZWxvcG1lbnQiLCJpc1Byb2R1Y3Rpb24iLCJpc1Rlc3QiLCJnZXRBcGlVcmwiLCJwYXRoIiwiY29uc29sZSIsImxvZyIsImdldEFwcFVybCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/config.ts\n"));

/***/ })

});